/*
READY-TO-DEPLOY React single-file app (App.jsx) for an Expense Tracker using Supabase.

Instructions:
1) Create a Supabase project and run the SQL below to create the `expenses` table:

   create table expenses (
       id bigint generated by default as identity primary key,
       date date not null,
       particulars text not null,
       type text check (type in ('Credit', 'Debit')) not null,
       comments text,
       amount numeric not null,
       balance numeric not null default 0
   );

2) In your Vercel / Netlify / local environment add env vars:
   REACT_APP_SUPABASE_URL=<your-supabase-url>
   REACT_APP_SUPABASE_ANON_KEY=<your-anon-key>

3) Project setup (example with Vite + React):
   npm create vite@latest my-expenses -- --template react
   cd my-expenses
   npm install @supabase/supabase-js
   (optional) install Tailwind CSS following Vite + Tailwind guide, or use plain CSS
   Replace src/App.jsx with this file. Start with `npm run dev`.

4) Deploy on Vercel: connect repo, Vercel will pick up env vars and build.

This file contains:
- Supabase client (uses env vars)
- App React component with add / filter / inline edit / delete / balance recalculation
- Minimal styling using Tailwind classes; if Tailwind isn't installed the layout still works with basic CSS.

*/

import React, { useEffect, useState } from 'react';
import { createClient } from '@supabase/supabase-js';

// --- Supabase client -------------------------------------------------
const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL;
const SUPABASE_ANON_KEY = import.meta.env.VITE_SUPABASE_ANON_KEY;

if (!SUPABASE_URL || !SUPABASE_ANON_KEY) {
  console.warn('Please set REACT_APP_SUPABASE_URL and REACT_APP_SUPABASE_ANON_KEY environment variables');
}

const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

// --- Utility: recalculate balances locally given a list of rows (sorted) ---
function recalcBalancesLocal(rows) {
  // rows assumed sorted by date asc then id asc
  let running = 0;
  return rows.map((r) => {
    const amt = Number(r.amount) || 0;
    if (r.type === 'Credit') running += amt;
    else running -= amt;
    return { ...r, balance: running };
  });
}

// --- Main App -------------------------------------------------------
export default function App() {
  const [expenses, setExpenses] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  // Add form state
  const [form, setForm] = useState({ date: '', particulars: '', type: 'Debit', comments: '', amount: '' });

  // Filters
  const [filter, setFilter] = useState({ from: '', to: '', q: '', type: 'All' });

  // Inline edit state
  const [editingId, setEditingId] = useState(null);
  const [editValues, setEditValues] = useState({});

  // refresh trigger
  const [refreshIndex, setRefreshIndex] = useState(0);

  useEffect(() => {
    fetchExpenses();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [refreshIndex]);

  async function fetchExpenses() {
    setLoading(true);
    setError(null);
    try {
      // load all rows, order by date then id
      let { data, error } = await supabase
        .from('expenses')
        .select('*')
        .order('date', { ascending: true })
        .order('id', { ascending: true });

      if (error) throw error;

      // Convert numeric fields to numbers
      data = data.map((r) => ({ ...r, amount: Number(r.amount), balance: Number(r.balance) }));

      // If balances look incorrect, recompute and persist
      const recalculated = recalcBalancesLocal(data);

      // If any balance differs, update those rows
      const updates = [];
      for (let i = 0; i < data.length; i++) {
        if (Number(data[i].balance) !== Number(recalculated[i].balance)) {
          updates.push({ id: data[i].id, balance: recalculated[i].balance });
        }
      }
      if (updates.length > 0) {
        // update balances one-by-one (keeps logic simple and robust)
        await Promise.all(
          updates.map((u) => supabase.from('expenses').update({ balance: u.balance }).eq('id', u.id))
        );
        // fetch again to get latest
        let { data: data2 } = await supabase.from('expenses').select('*').order('date', { ascending: true }).order('id', { ascending: true });
        data2 = data2.map((r) => ({ ...r, amount: Number(r.amount), balance: Number(r.balance) }));
        setExpenses(data2);
      } else {
        setExpenses(data);
      }
    } catch (err) {
      console.error(err);
      setError(err.message || 'Error fetching');
    } finally {
      setLoading(false);
    }
  }

  // --- Add entry ---------------------------------------------------
  async function handleAdd(e) {
    e.preventDefault();
    setError(null);
    try {
      if (!form.date || !form.particulars || !form.amount) {
        setError('Date, particulars and amount are required');
        return;
      }
      const amountNum = Number(form.amount);
      if (isNaN(amountNum)) {
        setError('Amount must be a number');
        return;
      }

      // Insert new row with a temporary balance of 0; we'll recalc and update after
      const { error } = await supabase.from('expenses').insert([
        {
          date: form.date,
          particulars: form.particulars,
          type: form.type,
          comments: form.comments || null,
          amount: amountNum,
          balance: 0,
        },
      ]);
      if (error) throw error;

      // clear form
      setForm({ date: '', particulars: '', type: 'Debit', comments: '', amount: '' });

      // trigger refresh to recalc balances
      setRefreshIndex((r) => r + 1);
    } catch (err) {
      console.error(err);
      setError(err.message || 'Error adding');
    }
  }

  // --- Delete entry -----------------------------------------------
  async function handleDelete(id) {
    if (!confirm('Delete this entry?')) return;
    setError(null);
    try {
      const { error } = await supabase.from('expenses').delete().eq('id', id);
      if (error) throw error;
      setRefreshIndex((r) => r + 1);
    } catch (err) {
      console.error(err);
      setError(err.message || 'Error deleting');
    }
  }

  // --- Start editing a row ---------------------------------------
  function startEdit(row) {
    setEditingId(row.id);
    setEditValues({ ...row });
  }

  function cancelEdit() {
    setEditingId(null);
    setEditValues({});
  }

  // --- Save edited row -------------------------------------------
  async function saveEdit(id) {
    setError(null);
    try {
      const { date, particulars, type, comments, amount } = editValues;
      if (!date || !particulars || amount === undefined || amount === null) {
        setError('Date, particulars and amount are required');
        return;
      }
      const amt = Number(amount);
      if (isNaN(amt)) {
        setError('Amount must be a number');
        return;
      }

      const { error } = await supabase.from('expenses').update({ date, particulars, type, comments, amount: amt }).eq('id', id);
      if (error) throw error;

      setEditingId(null);
      setEditValues({});

      // Recalc balances
      setRefreshIndex((r) => r + 1);
    } catch (err) {
      console.error(err);
      setError(err.message || 'Error saving edit');
    }
  }

  // --- Apply filters client side ---------------------------------
  function getFilteredRows() {
    const { from, to, q, type } = filter;
    let rows = [...expenses];
    if (from) rows = rows.filter((r) => new Date(r.date) >= new Date(from));
    if (to) rows = rows.filter((r) => new Date(r.date) <= new Date(to));
    if (q) rows = rows.filter((r) => r.particulars.toLowerCase().includes(q.toLowerCase()));
    if (type === 'Credit' || type === 'Debit') rows = rows.filter((r) => r.type === type);
    return rows;
  }

  const filtered = getFilteredRows();

  return (
    <div className="min-h-screen bg-gray-50 p-4">
      <div className="max-w-5xl mx-auto">
        <header className="mb-6">
          <h1 className="text-2xl font-semibold">Expense Tracker</h1>
          <p className="text-sm text-gray-600">React + Supabase â€” add, edit inline, delete, and auto-recalculate balances.</p>
        </header>

        <section className="bg-white p-4 rounded-lg shadow mb-6">
          <form onSubmit={handleAdd} className="grid grid-cols-1 md:grid-cols-6 gap-3">
            <input type="date" value={form.date} onChange={(e) => setForm({ ...form, date: e.target.value })} className="border p-2 rounded col-span-1 md:col-span-1" />
            <input placeholder="Particulars" value={form.particulars} onChange={(e) => setForm({ ...form, particulars: e.target.value })} className="border p-2 rounded col-span-1 md:col-span-2" />
            <select value={form.type} onChange={(e) => setForm({ ...form, type: e.target.value })} className="border p-2 rounded col-span-1 md:col-span-1">
              <option>Debit</option>
              <option>Credit</option>
            </select>
            <input placeholder="Amount" value={form.amount} onChange={(e) => setForm({ ...form, amount: e.target.value })} className="border p-2 rounded col-span-1 md:col-span-1" />
            <input placeholder="Comments (optional)" value={form.comments} onChange={(e) => setForm({ ...form, comments: e.target.value })} className="border p-2 rounded col-span-1 md:col-span-6" />

            <div className="col-span-1 md:col-span-6 text-right">
              <button type="submit" className="px-4 py-2 bg-blue-600 text-white rounded">Add</button>
            </div>
          </form>
          {error && <div className="text-red-600 mt-2">{error}</div>}
        </section>

        <section className="bg-white p-4 rounded-lg shadow mb-6">
          <h2 className="font-medium mb-2">Filters</h2>
          <div className="grid grid-cols-1 md:grid-cols-6 gap-3 items-end">
            <div>
              <label className="text-sm">From</label>
              <input type="date" value={filter.from} onChange={(e) => setFilter({ ...filter, from: e.target.value })} className="border p-2 rounded w-full" />
            </div>
            <div>
              <label className="text-sm">To</label>
              <input type="date" value={filter.to} onChange={(e) => setFilter({ ...filter, to: e.target.value })} className="border p-2 rounded w-full" />
            </div>
            <div className="md:col-span-2">
              <label className="text-sm">Search particulars</label>
              <input placeholder="Search..." value={filter.q} onChange={(e) => setFilter({ ...filter, q: e.target.value })} className="border p-2 rounded w-full" />
            </div>
            <div>
              <label className="text-sm">Type</label>
              <select value={filter.type} onChange={(e) => setFilter({ ...filter, type: e.target.value })} className="border p-2 rounded w-full">
                <option>All</option>
                <option>Credit</option>
                <option>Debit</option>
              </select>
            </div>
            <div className="text-right">
              <button onClick={() => { setFilter({ from: '', to: '', q: '', type: 'All' }); }} className="px-3 py-2 border rounded">Clear</button>
            </div>
          </div>
        </section>

        <section className="bg-white p-4 rounded-lg shadow">
          <div className="flex items-center justify-between mb-3">
            <h2 className="font-medium">Entries ({filtered.length})</h2>
            <div className="text-sm text-gray-600">{loading ? 'Loading...' : ''}</div>
          </div>

          <div className="overflow-x-auto">
            <table className="min-w-full table-auto border-collapse">
              <thead>
                <tr className="text-left">
                  <th className="p-2 border-b">Date</th>
                  <th className="p-2 border-b">Particulars</th>
                  <th className="p-2 border-b">Type</th>
                  <th className="p-2 border-b">Comments</th>
                  <th className="p-2 border-b">Amount</th>
                  <th className="p-2 border-b">Balance</th>
                  <th className="p-2 border-b">Actions</th>
                </tr>
              </thead>
              <tbody>
                {filtered.map((r) => (
                  <tr key={r.id} className="align-top">
                    <td className="p-2 border-b w-28">
                      {editingId === r.id ? (
                        <input type="date" value={editValues.date || ''} onChange={(e) => setEditValues({ ...editValues, date: e.target.value })} className="border p-1 rounded w-full" />
                      ) : (
                        r.date
                      )}
                    </td>
                    <td className="p-2 border-b">
                      {editingId === r.id ? (
                        <input value={editValues.particulars || ''} onChange={(e) => setEditValues({ ...editValues, particulars: e.target.value })} className="border p-1 rounded w-full" />
                      ) : (
                        r.particulars
                      )}
                    </td>
                    <td className="p-2 border-b w-28">
                      {editingId === r.id ? (
                        <select value={editValues.type || 'Debit'} onChange={(e) => setEditValues({ ...editValues, type: e.target.value })} className="border p-1 rounded w-full">
                          <option>Debit</option>
                          <option>Credit</option>
                        </select>
                      ) : (
                        r.type
                      )}
                    </td>
                    <td className="p-2 border-b max-w-xs">
                      {editingId === r.id ? (
                        <input value={editValues.comments || ''} onChange={(e) => setEditValues({ ...editValues, comments: e.target.value })} className="border p-1 rounded w-full" />
                      ) : (
                        r.comments
                      )}
                    </td>
                    <td className="p-2 border-b w-24 text-right">
                      {editingId === r.id ? (
                        <input value={editValues.amount || ''} onChange={(e) => setEditValues({ ...editValues, amount: e.target.value })} className="border p-1 rounded w-full text-right" />
                      ) : (
                        Number(r.amount).toFixed(2)
                      )}
                    </td>
                    <td className="p-2 border-b w-24 text-right">{Number(r.balance).toFixed(2)}</td>
                    <td className="p-2 border-b w-36">
                      {editingId === r.id ? (
                        <div className="flex gap-2">
                          <button onClick={() => saveEdit(r.id)} className="px-2 py-1 bg-green-600 text-white rounded">Save</button>
                          <button onClick={cancelEdit} className="px-2 py-1 border rounded">Cancel</button>
                        </div>
                      ) : (
                        <div className="flex gap-2">
                          <button onClick={() => startEdit(r)} className="px-2 py-1 border rounded">Edit</button>
                          <button onClick={() => handleDelete(r.id)} className="px-2 py-1 bg-red-600 text-white rounded">Delete</button>
                        </div>
                      )}
                    </td>
                  </tr>
                ))}

                {filtered.length === 0 && (
                  <tr>
                    <td colSpan={7} className="p-4 text-center text-gray-600">No rows to display</td>
                  </tr>
                )}
              </tbody>
            </table>
          </div>

          <div className="mt-3 text-sm text-gray-600">Tip: balances are recalculated automatically on add/edit/delete.</div>
        </section>
      </div>
    </div>
  );
}
